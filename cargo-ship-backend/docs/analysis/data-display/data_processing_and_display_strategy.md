# 数据处理与前端展示策略分析报告

本报告旨在总结当前系统中数据处理流程的分析结果，并为应对不同数据源（批量文件导入与实时数据流）提供一套完整、可扩展的架构方案。

## 1. 现有需求文档准确性评估

我们对 `docs/require/realtime_auto_data_requirements.md` 文件中的分析进行了验证，结论如下：

- **基本准确**: 该文档成功指出了系统中存在的两个关键功能缺失：
    1.  **实时数据推送缺失 (断点B)**: 系统在接收到新数据后，未将原始监测数据点通过 WebSocket 推送给前端。
    2.  **历史告警生成缺失 (断点C)**: 通过文件导入历史数据后，系统没有机制对这些数据进行告警回溯分析。

- **一处偏差**:
    - **实时告警触发 (断点A)**: 与文档描述不同，系统当前**已经实现**了实时的告警生成与推送功能。`MonitoringService` 在接收数据后会调用 `AlarmService` 进行处理。

- **架构现状**:
    - 系统目前采用**直接服务调用**的方式进行模块间通信，而非文档中建议的**事件驱动架构**。

**结论**: 该需求文档为后续开发提供了有效的目标，我们应重点关注“实时数据推送”和“历史告警回溯”两大功能的实现。

---

## 2. 方案一：基于文件导入的“模拟实时”展示方案

此方案旨在解决当前只有文件导入数据，但前端页面需要展示“实时”监控状态的问题。

**核心策略**：前端通过**定期轮询**后端接口获取最新数据，后端通过**缓存**提供快速响应，UI 清晰地展示**数据的时间戳**。

### 2.1. 后端改造

1.  **引入“最新值”缓存层**:
    - **技术**: 使用 Redis（项目已集成）。
    - **数据结构**: 建议使用 Hash，例如 Key: `latest_metrics:<equipment_id>`，Field: 指标名, Value: `{"value": 123, "timestamp": "..."}`。
2.  **改造 `ImportService`**:
    - 在文件导入成功后，遍历该批次数据，将每个监测点的最新值更新到 Redis 缓存中。
3.  **创建新 API 接口**:
    - 在 `MonitoringController` 中创建 `GET /api/monitoring/latest-metrics` 接口。
    - 该接口直接从 Redis 读取所有设备的最新值并返回，响应速度极快。

### 2.2. 前端改造

1.  **修改数据获取逻辑**:
    - 停用 WebSocket 逻辑，改为**定时轮询**（如每 5-10 秒）上述新 API。
2.  **关键 UI/UX 调整**:
    - **必须显示时间戳**: 在每个数据旁都展示其具体时间，例如 “电压: 400.5 V **(10:30:00)**”。
    - **展示数据新鲜度**: 在页面全局位置告知用户数据的截止时间，例如“数据更新于: 2025-12-07 文件导入”。
    - **高亮陈旧数据**: 当数据时间戳与当前时间差距过大时，用不同颜色或图标提示用户。

---

## 3. 方案二：兼容实时与批量的混合架构方案

此方案是方案一的超集，旨在构建一个面向未来的健壮架构，能够无缝兼容现有的文件导入模式和未来可能接入的第三方实时数据流。

**核心策略**: 通过**事件驱动架构**（`@nestjs/event-emitter`）解耦数据源和数据消费者，建立统一的数据处理流水线。

### 3.1. 架构逻辑

```text
                                  +---------------------------+
                                  |   @nestjs/event-emitter   |
                                  |      (事件总线)            |
                                  +-------------^-------------+
                                                | emits 'timeseries.data.received'
                                                |
                  +-----------------------------+-----------------------------+
                  |                                                           |
+-----------------v-------------+                             +---------------v---------------+
|        ImportService          |                             |   RealtimeIngestionService    |
|   (文件导入服务/批量数据源)      |                             | (对接第三方系统的实时数据源)     |
+-------------------------------+                             +-------------------------------+


                  +-----------------------------v-------------+
                  |        (事件监听器 - Consumers)            |
                  +-------------------------------------------+
                  |                                           |
        +---------v--------+    +-------------v-----------+   +-------------v-----------+
        |  AlarmService    |    |  LatestValueCacheService  |   |   WebsocketPushService    |
        | (处理告警)       |    |  (更新Redis最新值)        |   |  (通过WebSocket推送UI)  |
        +------------------+    +-------------------------+   +-------------------------+
```

### 3.2. 后端实现

1.  **引入事件模块**: 安装并配置 `@nestjs/event-emitter`。
2.  **改造数据源 (Producers)**:
    - **`ImportService`**: 在批量导入成功后，发出 `timeseries.data.received` 事件。
    - **创建 `RealtimeIngestionService`**: 负责连接第三方系统，每收到一条数据就发出 `timeseries.data.received` 事件。
3.  **创建事件监听器 (Listeners)**:
    - `AlarmService`, `LatestValueCacheService`, `WebsocketPushService` 都转为事件监听器，响应 `timeseries.data.received` 事件并执行各自的逻辑。

### 3.3. 前端实现

1.  **实现“混合模式”连接**:
    - **优先 WebSocket**: 页面加载时，优先尝试 WebSocket 连接以进入**实时模式**。
    - **自动降级为轮询**: 若 WebSocket 连接失败，则自动切换到**轮询模式**，调用 `GET /api/monitoring/latest-metrics` 接口。
2.  **UI 状态显示**:
    - 提供一个状态指示灯，清晰告知用户当前的数据连接模式（实时 🟢, 轮询 🟡, 断开 🔴）。

## 4. 结论与建议

- **方案对比**: 方案一解决了当前仅有文件导入的问题，而方案二是面向未来的完整解决方案，它完全兼容方案一。
- **实施建议**:
    1.  **推荐直接采纳方案二进行开发**，这将构建一个更健壮、可扩展的系统。
    2.  可以分步实施：首先完成后端事件总线和 `LatestValueCacheService` 的改造，以及前端的轮询机制（完成方案一的核心）。
    3.  随后，实现 `WebsocketPushService` 和前端的 WebSocket 对接，完成完整的混合模式。
    4.  最后，当第三方实时数据源可用时，只需开发 `RealtimeIngestionService` 并将其接入事件总线即可，其他模块无需任何改动。
