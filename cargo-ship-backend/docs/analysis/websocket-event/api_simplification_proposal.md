# WebSocket API 设计分析与精简方案

## 1. 核心问题

经过深入分析，当前的 WebSocket API 设计存在**过度设计**的问题，导致了不必要的**复杂性和功能冗余**。我们应聚焦于实时通信的核心价值，剥离非必要事件，合并重复功能。

---

## 2. 精简原则与具体分析

### 2.1. 推送范围：聚焦核心实时信息
**原则**: 只推送高价值、高时效性的核心数据。
**结论**: `设备实时数据`、`告警信息`和`健康信息`是必要的。其他如用户上下线、设备元信息变更等，其实时性要求不高，应通过标准 REST API 进行管理。

**建议移除的事件**:
- `user:online` / `user:offline`
- `equipment:status:change`
- `equipment:update` / `created` / `deleted`
- `equipment:overview:update`

### 2.2. 功能冗余：合并重复事件

#### 告警事件
- **`alarm:historical-batch` 与 `alarm:batch`**:
  - **问题**: 完全重复，都用于批量推送告警。
  - **方案**: **合并**。只保留 `alarm:batch`，统一用于所有批量告警场景。

- **`alarm:update` 与 `alarm:new`**:
  - **问题**: 虽然代表“创建”与“更新”，但从客户端角度看，都是“告警状态的最新版本”，造成了不必要的逻辑分支。
  - **方案**: **合并为一个 `alarm:push` 事件**。无论是新告警还是状态更新，后端都用此事件发送该告警的**完整、最新**数据。客户端只需执行“更新或插入 (Upsert)”逻辑即可。

#### 数据推送事件
- **`import:latest-data`、`equipment:data:realtime` 与 `monitoring:new-data`**:
  - **问题**: 三个事件功能完全一样。
  - **方案**: **合并**。只保留 `monitoring:new-data` 作为所有设备数据的唯一推送通道，并通过 `source` 字段区分数据来源。

### 2.3. 聚合通知：移除不必要的“提醒”事件

- **`alarm:count:update`**:
  - **问题**: 这是一个“提醒客户端刷新”的事件，增加了API的复杂性。
  - **方案**: **移除**。客户端应有能力根据收到的 `alarm:push` 或 `alarm:batch` 事件自行更新本地的告警计数。这简化了服务端的设计，是更优的实践。

---

## 3. 最终版：精简后的 WebSocket API 方案

基于以上分析，我们提出一个更健壮、更易于维护的全新 WebSocket 事件列表：

| 事件名称 | 触发时机与核心职责 |
| :--- | :--- |
| **`monitoring:new-data`** | **（统一入口）**<br>当有任何新的设备监测数据时触发。这是设备数据的 **唯一** 实时来源。 |
| **`alarm:push`** | **（合并后）**<br>当一个告警被创建或其状态被更新时触发。携带该告警的 **完整、最新** 状态。 |
| **`alarm:batch`** | **（统一入口）**<br>当需要一次性推送多条告警时触发（主要用于历史数据导入场景）。 |
| **`equipment:health:update`** | **（保留）**<br>当设备健康评分计算完成后，向订阅该设备的用户推送最新评分。 |
| **`equipment:health:warning`** | **（建议保留）**<br>当设备健康评分低于预警阈值时，专门向管理员角色推送。这是一个高价值、低频率的定向通知。 |

这个精简方案抓住了实时通信的重点，消除了所有不必要的复杂性，将使后端实现更清晰，前端开发更简单。
