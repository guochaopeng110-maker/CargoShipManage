# 告警管理能力规范增量

本文档定义了告警中心页面的功能需求和场景。

---

## ADDED Requirements

### Requirement: 双模视图告警管理界面

系统应当（SHALL）提供一个统一的告警中心页面，通过标签页（Tabs）组件实现"实时告警"和"历史告警"两种视图模式，使用户能够在同一个页面中完成实时监控和历史追溯两种场景的告警管理任务。

#### Scenario: 用户查看实时告警列表

- **GIVEN** 用户已登录系统并访问告警中心页面
- **WHEN** 用户选择"实时告警"标签页
- **THEN** 系统应当展示当前活动的告警列表
- **AND** 告警列表应当自动响应 WebSocket 推送的新告警
- **AND** 页面顶部应当显示统计卡片（待处理告警数、严重告警数、紧急告警数）
- **AND** 用户无需手动刷新页面即可看到最新的告警信息

#### Scenario: 用户查询历史告警

- **GIVEN** 用户已登录系统并访问告警中心页面
- **WHEN** 用户选择"历史告警"标签页
- **AND** 用户配置筛选条件（设备、告警等级、状态、日期范围）
- **AND** 用户点击"执行查询"按钮
- **THEN** 系统应当发送 API 请求获取符合条件的历史告警
- **AND** 系统应当展示查询结果的分页列表
- **AND** 用户应当能够通过分页组件浏览所有查询结果

#### Scenario: 用户在不同视图间切换

- **GIVEN** 用户正在查看某个标签页
- **WHEN** 用户点击另一个标签页
- **THEN** 系统应当立即切换视图
- **AND** 系统应当保留之前视图的状态（如筛选条件、页码）
- **AND** 切换过程应当流畅无卡顿

---

### Requirement: 实时告警自动推送和展示

系统应当（SHALL）通过 WebSocket 实时推送告警数据，前端应当自动接收并展示新的告警，无需用户手动刷新页面。

#### Scenario: 接收并展示新的实时告警

- **GIVEN** 用户正在查看"实时告警"标签页
- **AND** WebSocket 连接正常
- **WHEN** 后端通过 WebSocket 推送 `alarm:push` 事件
- **THEN** 前端 `realtime-service` 应当接收该事件
- **AND** `alarms-store` 的 `handleRealtimeAlarm` 方法应当处理该事件
- **AND** 新告警应当自动添加到 `activeAlarms` 列表顶部
- **AND** UI 应当自动刷新，展示新告警
- **AND** 统计卡片的数据应当自动更新

#### Scenario: 接收批量告警推送

- **GIVEN** 用户正在查看"实时告警"标签页
- **WHEN** 后端通过 WebSocket 推送 `alarm:batch` 事件（包含多个告警）
- **THEN** 系统应当批量处理所有告警
- **AND** 告警列表应当自动更新
- **AND** 系统应当去重，避免重复显示相同的告警

#### Scenario: WebSocket 连接断开

- **GIVEN** 用户正在查看"实时告警"标签页
- **WHEN** WebSocket 连接断开
- **THEN** 系统应当显示"实时连接已断开"的警告提示
- **AND** 系统应当自动尝试重连
- **AND** 重连成功后，系统应当恢复告警推送
- **AND** 系统应当显示"实时连接已恢复"的成功提示

---

### Requirement: 告警确认闭环数据流

系统应当（SHALL）提供告警确认功能，并确保用户的确认操作能够通过 API 请求、WebSocket 推送和状态更新形成完整的闭环反馈。

#### Scenario: 用户确认告警成功

- **GIVEN** 用户正在查看"实时告警"标签页
- **AND** 告警列表中存在待处理的告警
- **WHEN** 用户点击某个告警的"确认"按钮
- **THEN** 系统应当调用 `alarms-store.acknowledgeAlarm(alarmId)` 方法
- **AND** 该方法应当通过 `alarms-service` 发送 `POST /api/alarms/{alarmId}/ack` API 请求
- **AND** 后端处理成功后，应当通过 WebSocket 推送 `alarm:update` 事件
- **AND** 前端 `alarms-store.handleRealtimeAlarm` 应当接收并处理该事件
- **AND** 已确认的告警应当从 `activeAlarms` 列表中移除
- **AND** 告警应当从 `pendingAlarms` 和 `emergencyAlarms` 列表中移除（如果存在）
- **AND** UI 应当自动刷新，已确认的告警消失
- **AND** 系统应当显示"告警已确认"的成功提示

#### Scenario: 告警确认失败

- **GIVEN** 用户正在查看"实时告警"标签页
- **WHEN** 用户点击某个告警的"确认"按钮
- **AND** API 请求失败（网络错误或后端错误）
- **THEN** 系统应当显示"确认失败"的错误提示
- **AND** 告警应当保留在列表中
- **AND** 用户应当能够重新尝试确认操作

#### Scenario: 无权限确认告警

- **GIVEN** 用户没有告警确认权限
- **WHEN** 用户查看"实时告警"标签页
- **THEN** 系统不应当显示"确认"按钮
- **OR** 如果显示"确认"按钮，点击后应当提示"权限不足"

---

### Requirement: 历史告警筛选和分页查询

系统应当（SHALL）提供灵活的历史告警查询功能，支持按设备、告警等级、状态、日期范围等条件进行筛选，并支持分页浏览查询结果。

#### Scenario: 用户按条件查询历史告警

- **GIVEN** 用户正在查看"历史告警"标签页
- **WHEN** 用户选择设备 "主引擎"
- **AND** 用户选择告警等级 "高" 和 "严重"
- **AND** 用户选择日期范围为 "最近7天"
- **AND** 用户点击"执行查询"按钮
- **THEN** 系统应当调用 `alarms-store.fetchHistoricalAlarms(filters, page)` 方法
- **AND** 该方法应当设置 `queryStatus` 为 `'loading'`
- **AND** 系统应当通过 `alarms-service` 发送 `GET /api/alarms/history` API 请求
- **AND** 请求参数应当包含所有筛选条件
- **AND** 系统应当接收分页数据并更新 `historicalAlarms` 状态
- **AND** `queryStatus` 应当变为 `'success'`
- **AND** UI 应当展示查询结果的表格和分页组件

#### Scenario: 用户切换查询结果的页码

- **GIVEN** 用户已经查询了历史告警并看到第一页的结果
- **WHEN** 用户点击分页组件的"下一页"按钮
- **THEN** 系统应当调用 `alarms-store.setQueryPage(2)` 方法
- **AND** 系统应当使用相同的筛选条件请求第二页的数据
- **AND** 系统应当更新 `historicalAlarms` 状态
- **AND** UI 应当展示第二页的查询结果

#### Scenario: 历史查询返回空结果

- **GIVEN** 用户配置了筛选条件
- **WHEN** 用户点击"执行查询"按钮
- **AND** API 返回空数据（total = 0）
- **THEN** 系统应当显示"未找到符合条件的告警"的空状态提示
- **AND** 系统应当建议用户调整筛选条件

#### Scenario: 历史查询失败

- **GIVEN** 用户配置了筛选条件并点击"执行查询"
- **WHEN** API 请求失败
- **THEN** 系统应当设置 `queryStatus` 为 `'error'`
- **AND** 系统应当显示错误提示消息
- **AND** 系统应当提供"重试"按钮供用户再次查询

---

### Requirement: 筛选条件用户体验优化

系统应当（SHALL）提供用户友好的筛选条件界面，包括快捷日期选项、多选组件和筛选条件重置功能。

#### Scenario: 用户使用快捷日期选项

- **GIVEN** 用户正在配置历史告警的筛选条件
- **WHEN** 用户点击"最近7天"快捷选项
- **THEN** 系统应当自动设置日期范围为当前时间往前推7天至今
- **AND** 日期选择器应当显示对应的日期范围

#### Scenario: 用户重置筛选条件

- **GIVEN** 用户已经配置了多个筛选条件
- **WHEN** 用户点击"重置筛选"按钮
- **THEN** 系统应当清空所有筛选条件
- **AND** 系统应当恢复筛选表单的默认状态
- **AND** 查询结果应当保持不变（直到用户再次点击"执行查询"）

#### Scenario: 用户选择多个告警等级

- **GIVEN** 用户正在配置筛选条件
- **WHEN** 用户选择告警等级 "高" 和 "严重"
- **THEN** 系统应当在筛选条件中包含这两个等级
- **AND** 查询结果应当包含所有等级为 "高" 或 "严重" 的告警

---

### Requirement: 告警数据表格展示

系统应当（SHALL）提供清晰、易读的告警数据表格，展示告警的关键信息，并支持响应式布局。

#### Scenario: 展示告警表格的关键信息

- **GIVEN** 用户正在查看告警列表（实时或历史）
- **THEN** 告警表格应当包含以下列：
  - 告警 ID
  - 设备名称
  - 指标类型
  - 告警等级（带颜色标识）
  - 告警状态
  - 触发时间
  - 告警消息
  - 操作按钮（实时告警视图）
- **AND** 告警等级应当使用颜色区分（低-蓝、中-黄、高-橙、严重-红）
- **AND** 表格应当支持水平滚动（在窄屏设备上）

#### Scenario: 告警表格的响应式布局

- **GIVEN** 用户在移动设备上访问告警中心页面
- **WHEN** 用户查看告警表格
- **THEN** 表格应当适配移动设备的屏幕宽度
- **AND** 不重要的列应当隐藏或折叠
- **AND** 用户应当能够通过横向滑动查看所有列

---

### Requirement: 告警统计卡片展示

系统应当（SHALL）在实时告警视图的顶部展示统计卡片，提供告警数量的快速概览。

#### Scenario: 展示告警统计卡片

- **GIVEN** 用户正在查看"实时告警"标签页
- **THEN** 页面顶部应当展示三个统计卡片：
  1. 待处理告警数（来自 `pendingAlarms.length`）
  2. 严重告警数（来自 `criticalAlarms.length`）
  3. 紧急告警数（来自 `emergencyAlarms.length`）
- **AND** 统计卡片应当随着告警列表的变化自动更新

#### Scenario: 统计卡片的实时更新

- **GIVEN** 用户正在查看"实时告警"标签页
- **WHEN** 新的严重告警通过 WebSocket 推送到前端
- **THEN** "严重告警数" 卡片应当自动增加计数
- **AND** 如果新告警的状态为 "待处理"，"待处理告警数" 卡片也应当增加
- **AND** 更新应当无延迟，与告警列表同步

---

## 实现说明

本规范定义的功能将通过以下技术实现：

1. **UI 层**：
   - `AlarmCenterPage.tsx`：主组件，管理 Tabs 切换
   - `RealTimeAlarmsView.tsx`：实时告警视图
   - `HistoricalAlarmsView.tsx`：历史告警视图
   - `AlarmFilters.tsx`：筛选条件组件
   - `AlarmTable.tsx`：告警表格（可复用）

2. **状态管理层**：
   - `alarms-store.ts`：扩展实时和历史告警状态管理

3. **服务层**：
   - `alarms-service.ts`：封装告警 API 调用
   - `realtime-service.ts`：管理 WebSocket 连接

4. **通信层**：
   - REST API：历史告警查询、告警确认
   - WebSocket：实时告警推送

---

## 验收标准

1. 用户能够在一个页面中通过 Tabs 切换查看实时告警和历史告警
2. 实时告警能够自动推送并展示，无需手动刷新
3. 用户能够按条件筛选和分页浏览历史告警
4. 用户确认告警后，系统能够通过闭环数据流自动更新 UI
5. 所有场景的加载状态、错误处理和空状态提示正常
6. 页面在桌面和移动设备上的响应式布局正常

---

**规范版本**: 1.0
**最后更新**: 2025-12-14
