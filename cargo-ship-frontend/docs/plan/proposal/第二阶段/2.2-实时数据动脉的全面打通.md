  这是本阶段的最后一个概念草稿，它的目标是打通我们整个应用的数据血脉，让第一阶段搭建的框架真正地“活”起
  来。

  概念草稿：[阶段二] 任务2.2 - 完善数据动脉（服务与状态集成）

   * 目标 (Objective):
      将第一阶段搭建的数据服务框架 (realtime-service) 和状态管理框架 (Zustand stores)
  进行深度的功能实现与集成，构建一条从后端数据源（API 与
  WebSocket）到前端状态，再到UI组件的、完整、健壮且类型安全的数据流管道。

   * 核心概念 (Core Concept):
       1. `realtime-service` 功能补完:
           * 实现连接与认证: 在其 connect 方法中，实现完整的 socket.io-client
             连接逻辑。一旦连接成功，必须立即从 auth-store 中获取认证token，并发送 authenticate       
             事件到服务器。
           * 实现订阅管理: 完整实现 subscribeToEquipment(id) 和 unsubscribeFromEquipment(id)
             方法，使其能够正确地发送 subscribe:equipment 和 unsubscribe:equipment
             socket事件。需要处理订阅引用计数，确保多个组件订阅同一个设备时只发送一次底层socket事件， 
             并在所有组件都取消订阅后才发送取消事件。
           * 实现事件分发: 将之前简单的 console.log 升级为一个真正的事件分发器。realtime-service      
             监听所有后端推送事件后，应通过一个可靠的机制（如 EventEmitter
             库或自定义回调）发出更通用的内部事件，例如 on('monitoring-update', callback) 和
             on('alarm-push', callback)。
       2. Zustand `stores` 逻辑实现与集成:
           * 订阅实时数据:
               * 在 monitoring-store 和 alarms-store 中，实现一个 init()
                 action。这个action会在应用启动或用户登录后被调用，其内部会执行
                 realtimeService.on('monitoring-update', ...) 来注册回调，开始监听实时数据。
           * 实现数据更新Actions:
               * 在 monitoring-store 中，创建一个 updateMonitoringData(data) action。此action负责将从 
                 realtime-service
                 回调中接收到的新监控数据高效地合并到现有的状态中（例如，更新一个以设备ID为key的map） 
                 。
               * 在 alarms-store 中，创建一个 pushNewAlarm(alarm)
                 action，将新告警添加到告警列表的顶部。
           * 调用自动化API Client: 在需要通过HTTP交互的 stores 中（如 auth-store,
             equipment-store），其actions（例如 login, fetchEquipments）应该去调用
             第一阶段生成的自动化API客户端 来执行网络请求，并将请求结果存入各自的state中。

   * 预期成果 (Expected Outcome):
       * realtime-service.ts 成为一个功能完整的模块，能够独立管理WebSocket连接、认证、订阅和数据分发。
       * monitoring-store.ts 和 alarms-store.ts 能够通过 realtime-service
         成功接收到后端推送的数据，并正确地更新其内部状态。
       * auth-store.ts 能够使用自动化API客户端成功完成登录操作，并将获取的token存入state，此token可被
         realtime-service 用于连接认证。
       * 数据流全链路打通：从后端数据源 -> `realtime-service` -> Zustand `stores`。
       * 可以通过React DevTools等工具，清晰地观察到Zustand
         stores的状态正在被实时推送的数据所改变，为下一阶段的UI重构提供了坚实的数据基础。


-------

概念草稿：[阶段二] 任务2.2 - 实时数据动脉的全面打通（Realtime Service & Stores集成）

   * 目标 (Objective):
      全面激活前端的实时数据流，将第一阶段搭建的 realtime-service 框架与 Zustand stores
  状态管理层无缝集成。这将确保所有从后端 WebSocket 推送来的实时数据能够准确、高效地注入到相应的 stores
  中，从而驱动 UI 的响应式更新。

   * 核心概念 (Core Concept):
       1. `realtime-service.ts` 全功能实现:
           * 连接与认证: 基于 websocket-api.md 规范，实现 realtime-service.ts 完整的 WebSocket
             连接、JWT 认证（从 auth-store 或 localStorage 获取
             Token），并健壮处理连接的生命周期事件（如 connected, disconnect, connect_error）。
           * 订阅管理: 完整实现 subscribeToEquipment(equipmentId: string) 和
             unsubscribeFromEquipment(equipmentId: string) 方法，使其能够向服务器发送正确的
             subscribe:equipment 和 unsubscribe:equipment 事件。
           * 事件监听与分发: 实现对 websocket-api.md 中定义的所有服务端推送事件（包括但不限于
             alarm:push, monitoring:new-data, equipment:health:update, equipment:health:warning,
             alarm:batch, alarm:trend）的监听。当接收到事件时，realtime-service
             应通过预定义的回调机制（例如，store 在服务初始化时注册的监听器）将数据分发给相应的
             Zustand stores。
       2. `Zustand stores` 实时数据集成:
           * 事件监听注册: 每个相关的 Zustand store（例如 monitoring-store, alarms-store,
             health-store）在初始化时，应向 realtime-service
             注册其对特定实时事件的监听器（回调函数）。
           * 状态更新逻辑: 当 store 的监听器接收到 realtime-service 分发的数据时，store
             应根据接收到的数据结构（利用第一阶段定义的类型安全），以不可变的方式更新其内部状态。这可
             能涉及添加新数据点、更新现有记录或调整统计信息。
           * 数据流原则落实:
             确保严格遵循“所有设备数据（无论是历史数据查询还是实时数据更新），均被视为由后端通过
             WebSocket 推送而来的统一数据流”的原则。stores 应成为 UI
             消费数据的唯一真理源，无需区分数据是首次加载还是实时推送。

   * 预期成果 (Expected Outcome):
       * realtime-service.ts 成为一个功能完备的模块，能够全生命周期管理 WebSocket
         连接、认证、订阅，并准确高效地分发所有实时事件。
       * monitoring-store, alarms-store, health-store 等核心 stores 能够无缝接收、处理并存储
         realtime-service 推送的实时数据，自动更新应用状态。
       * 建立起一个清晰、端到端的实时数据流，从后端 WebSocket 服务器直达前端的 Zustand stores。       
       * 可以通过简单的测试页面，验证集成后的 stores 能够响应实时数据更新，并驱动 UI
         展示出最新的状态。

----