  这是本阶段最后一个概念草稿，它将把我们之前准备好的数据服务（自动化API和实时服务）与未来的UI组件连接
  起来。

  概念草稿：[阶段一] 任务1.3 - 模块化状态管理（Zustand Stores）结构

   * 目标 (Objective):

  建立一套清晰、可预测且易于维护的前端状态管理架构。此架构将充当连接数据服务层（API客户端、WebSocket服
  务）与UI组件层的核心桥梁，并作为应用内业务逻辑和客户端状态的主要载体。

   * 核心概念 (Core Concept):
       1. 按业务领域划分 (Domain-Driven Structure):
           * 在 src/stores 目录下，严格按照业务领域（而非页面）来创建独立的Store文件。
           * 初步规划的核心Stores:
               * auth-store.ts: 负责用户认证状态、Token、个人资料和权限。
               * equipment-store.ts: 负责管理设备列表及其元数据（来自API）。
               * monitoring-store.ts: 负责管理所有设备的实时监控数据流。
               * alarms-store.ts: 负责管理实时告警推送和历史告警数据。
               * health-store.ts: 负责健康评估报告的生成与查询。
               * ui-store.ts: (可选但推荐)
                 负责管理全局UI状态，如侧边栏的展开/折叠、全局Loading、通知等。
       2. State 与 Actions 分离:
           * 在每个Store内部，结构上要明确分离 state (数据本身) 和 actions (修改数据的方法)。
           * actions 将封装所有修改 state 的业务逻辑，它们是唯一可以调用 自动化API客户端 (任务1.1)
             和订阅/响应 `realtime-service` (任务1.2) 的地方。
       3. 连接数据服务:
           * 这是stores的核心职责。例如：
               * auth-store 的 login action 将调用 自动化API客户端 的登录方法。
               * monitoring-store 需要有一个 init 或类似的 action，在此 action 内部订阅
                 realtime-service 的 monitoring:new-data 事件，并将收到的数据更新到自己的 state 中。
       4. 提供Selectors以优化性能:
           * 为了防止不必要的组件重渲染，每个Store都应鼓励使用 selector 函数来精确订阅所需的状态片段。

   * 预期成果 (Expected Outcome):
       * 在 src/stores 目录下创建好上述规划的Store文件，每个文件都包含基本的 state 结构、空的 actions
         对象和相应的TypeScript接口。
       * 在 monitoring-store.ts 和 alarms-store.ts 中，有明确的占位逻辑（例如在一个 init
         action里），用于展示如何订阅 realtime-service 的事件。
       * 在 auth-store.ts 和 equipment-store.ts 中，有明确的占位逻辑，用于展示如何调用 自动化API客户端
         来获取数据。
       * 为未来的UI组件层提供了一套清晰的状态消费模式，开发者可以明确地使用 useAuthStore(state =>
         state.user) 或 useAlarmsStore(state => state.activeAlarms) 等Hooks来驱动视图。

  至此，第一阶段：地基与准备                                                                          
  的所有概念草稿均已提出。完成这一步后，我们的前端应用将拥有一个极其现代化和强大的数据基础。