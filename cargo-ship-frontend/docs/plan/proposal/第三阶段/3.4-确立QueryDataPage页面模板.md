  概念草稿：[阶段三] 任务3.4 - 确立 `DataQueryPage` 页面模板

   * 目标 (Objective):
      将 DataQueryPage
  重构为一个以数据表格为中心的、简洁高效的工具。新模板将彻底简化UI，并为用户发起的、基于REST
  API的、分页的历史数据查询建立一个清晰、标准的数据流模式。

   * 核心概念 (Core Concept):
       1. UI/UX 核心：聚焦于表格 (Table-Centric Design):
           * 整体布局:
             页面简化为“查询条件区”和“结果展示区”上下两部分。移除所有图表、Tabs等与核心查询功能无关的
             组件。
           * 查询条件区:
               * 精简为三个核心筛选控件：设备选择（单选）、监控参数（多选）、日期范围选择。
               * 使用标准的“日期范围选择器”（Date Range
                 Picker）替代原有的独立起止时间输入，并提供“最近7天”等快捷选项。
               * 移除所有“高级选项”（如时间粒度、聚合类型等）。
           * 结果展示区:
               * 页面只包含一个带分页功能的数据表格。
               * 表格下方是一个独立的 Pagination 分页组件，用于显示页码、总页数并支持页面跳转。
           * 功能操作区:
               * 保留“执行查询”和“数据导出”（支持 Excel, CSV, JSON）功能。
       2. 数据流：用户驱动的API请求 (User-Initiated API Flow):
          此页面的数据流与实时监控页面不同，它是由用户操作触发的、基于 api-client 的请求-响应模式。
           * 触发: 用户配置好筛选条件后，点击“执行查询”按钮。
           * Action调用: 按钮点击事件将调用 monitoring-store 中一个专门的 action，例如
             fetchHistoricalData(filters, page).
           * API请求: 该 action 负责：
               1. 将日期范围转换为时间戳。
               2. 携带所有筛选条件和分页参数（如 page, pageSize）。
               3. 调用 api-client 中对应 GET /api/monitoring/data 的方法，向后端发起请求。
           * `Store`状态管理: monitoring-store 需要扩展，以管理与历史查询相关的独立状态，例如：
               * historicalData: { items: [], total: 0, page: 1, pageSize: 20 }
               * queryStatus: 'idle' | 'loading' | 'success' | 'error'
           * UI响应:
               * 数据表格和分页组件都响应 historicalData 的变化。
               * 页面根据 queryStatus 显示加载动画或错误提示。

   * 预期成果 (Expected Outcome):
       * 一个重构后的 DataQueryPage.tsx，界面清爽，完全聚焦于数据查询和导出这一核心功能。
       * monitoring-store
         的能力得到扩展，能够清晰地管理两种不同性质的数据：一种是实时推送的数据流，另一种是用户发起的 
         、分页的API查询结果。
       * 一个可供其他模块（如历史告警查询、操作日志查询）复用的、标准的“筛选-分页列表”页面开发模式被确
         立下来。
       * 用户获得了一个更简单、更直观、响应更快的历史数据探索体验。